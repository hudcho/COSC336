\iffalse

INSTRUCTIONS: (if this is not lecture1.tex, use the right file name)

  Clip out the ********* INSERT HERE ********* bits below and insert
appropriate TeX code.  Once you are done with your file, run

  ``latex lecture1.tex''

from a UNIX prompt.  If your LaTeX code is clean, the latex will exit
back to a prompt.  Once this is done, run

  ``dvips lecture1.dvi''

which should print your file to the nearest printer.  There will be
residual files called lecture1.log, lecture1.aux, and lecture1.dvi.
All these can be deleted, but do not delete lecture1.tex.
\fi
%
\documentclass[11pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{hyperref}
\usepackage{listings}

\lstdefinestyle{mystyle}{
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}
\lstset{style=mystyle}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
 
\urlstyle{same}

\setlength{\oddsidemargin}{.25in}
\setlength{\evensidemargin}{.25in}
\setlength{\textwidth}{6in}
\setlength{\topmargin}{-0.4in}
\setlength{\textheight}{8.5in}

\newcommand{\handout}[5]{
   %\renewcommand{\thepage}{#1-\arabic{page}}
   \noindent
   \begin{center}
   \framebox{
      \vbox{
    \hbox to 5.78in { {\bf Data Structures and Algorithms} \hfill #2 }
       \vspace{4mm}
       \hbox to 5.78in { {\Large \hfill #5  \hfill} }
       \vspace{2mm}
       \hbox to 5.78in { {\it #3 \hfill #4} }
      }
   }
   \end{center}
   \vspace*{4mm}
}

\newcommand{\lecture}[3]{\handout{L#1}{#2}{}{}{#1}}

\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}
\def\qed{\hspace*{\fill}
        \vbox{\hrule\hbox{\vrule\squarebox{.667em}\vrule}\hrule}}
\newenvironment{solution}{\begin{trivlist}\item[]{\bf Solution:}}
                      {\qed \end{trivlist}}
\newenvironment{solsketch}{\begin{trivlist}\item[]{\bf Solution Sketch:}}
                      {\qed \end{trivlist}}
\newenvironment{proof}{\begin{trivlist}\item[]{\bf Proof:}}
                      {\qed \end{trivlist}}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{Assertion}[theorem]{Assertion}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{hypothesis}[theorem]{Hypothesis}
%\newtheorem{observation}[theorem]{Observation}
%\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{assumption}[theorem]{Assumption}

%Put more macros here, as needed.
\newcommand{\al}{\alpha}
\newcommand{\Z}{\mathbb Z}
\newcommand{\jac}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\set}[1]{\{#1\}}

\def\ppt{{\sf PPT}}
\def\poly{{\sf poly}}
\def\negl{{\sf negl}}
\def\owf{{\sf OWF}}
\def\owp{{\sf OWP}}
\def\tdp{{\sf TDP}}
\def\prg{{\sf PRG}}
\def\prf{{\sf PRF}}

%end of macros
\begin{document}
\fbox{
\vbox{
\begin{flushleft}
Hudson Cho, Ryan Wilson, Jesse Washburn, Colin Shuster, Samhith Patibandla\\  % authors' names
COSC 336 \\  %class
03/4/2025\\  % date
\end{flushleft}
\center{\Large{\textbf{Assignment 3}}}
%\end{mdframed}
} % end vbox
} % end fbox
\vline


\textbf{Instructions.}
\begin{enumerate}
\item Due date and time: As indicated on Blackboard. 
\item This is a team assignment. Work in teams of 3-4 students.  Submit on Blackboard one assignment per team, with the names of all students making the team. 
\item The exercises will not be graded, but you still need to present your best attempt to solve them. If you do not know how to solve an exercise, say it.  This will give me feedback about your understanding of the theoretical concepts.
\item Your programs must be written in Java.

\item Write your programs neatly - imagine yourself grading your program and see if it is easy to read and understand. 

Comment your programs reasonably: there is no need to comment lines like "i++" but do include brief comments describing the main purpose of a specific block of lines.
\item  You will submit on \textbf{Blackboard} 3 files.  

The \textbf{1-st file} is a pdf file (produced ideally with latex and Overleaf) and it will contain the following:
\begin{enumerate}
\item The solution to the Exercises (see the remark above).
\item   A short description of your algorithms for the Programming Task1, where you explain your algorithms. Focus on how you have modified MERGE (for task 1), and on the relations between subproblems for the dynamic algorithm (for task 2)..
\item    Tables clearly labeled with the results your programs give for the data sets indicated for the programming tasks. 
\item   The java code (so that the grader can make observations) of the  2 programs (for task 1 and for task 2).
\end{enumerate}


The \textbf{2-nd file} is the .java file containing the java source code for Programming Task 1.


The \textbf{3-rd file} is the .java file containing the java source code for Programming Task 2.
\end{enumerate}
\newpage

\textbf{Exercise 1.}  Analyze the following recurrences using the method that is indicated. In case you use the Master Theorem, state what the corresponding values of $a$, $b$, and $f(n)$ are and how
you determined which case of the theorem applies. 

\begin{itemize}
\item  $T(n) = 3 T\left(\frac{n}{4}\right) + 3$. Use the Master Theorem to find a $\Theta()$ evaluation, or say "Master Theorem cannot be used", if this is the case.
\item  $T(n) = 2 T\left(\frac{n}{2}\right) + 3n$. Use the Master Theorem to find a $\Theta()$ evaluation, or say "Master Theorem cannot be used", if this is the case.
\item  $T(n) = 9 T\left(\frac{n}{3}\right) + n^2 \log n $. Use the Master Theorem to find a $\Theta()$ evaluation, or say "Master Theorem cannot be used", if this is the case.
\end{itemize}

\bigskip
\textbf{Answers:}

\begin{enumerate}
\item For $T(n) = 3 T\left(\frac{n}{4}\right) + 3$:
\[
a=3,\quad b=4,\quad f(n)=3.
\]
We compute 
\[
n^{\log_4 3}.
\]
Since $f(n)=3=\Theta(1)$, and $\Theta(1)=O\Bigl(n^{\log_4 3-\epsilon}\Bigr)$ for any $\epsilon>0$, we are in Case 1 of the Master Theorem. So,
{\boldmath\[
\quad T(n)=\Theta\Bigl(n^{\log_4 3}\Bigr)
\]}

\item For $T(n) = 2 T\left(\frac{n}{2}\right) + 3n$:
\[
a=2,\quad b=2,\quad f(n)=3n.
\]
We compute 
\[
n^{\log_2 2}=n.
\]
Since $f(n)=\Theta(n)$, which is the same as $n^{\log_2 2}$, we are in \textbf{Case 2} of the Master Theorem. So,
{\boldmath\[
T(n)=\Theta(n\log n).
\]}

\item For $T(n) = 9 T\left(\frac{n}{3}\right) + n^2 \log n$:
\[
a=9,\quad b=3,\quad f(n)=n^2\log n.
\]
We compute 
\[
n^{\log_3 9}=n^{\log_3 (3^2)}=n^2.
\]
Comparing \( f(n) \) with \( n^{\log_b a} \):
\[
\frac{f(n)}{n^2} = \frac{n^2 \log n}{n^2} = \log n.
\]
Since the extra factor is only \( \log n \) (which is not a polynomial factor), the difference between \( f(n) \) and \( n^2 \) is less than a polynomial factor.

The standard Master Theorem requires that \( f(n) \) be either polynomially smaller or larger than \( n^{\log_b a} \) (i.e., differing by a factor of \( n^\epsilon \) for some \( \epsilon > 0 \)). Since \( \log n \) grows slower than any positive power of \( n \), \textbf{the standard Master Theorem cannot be used.}

\end{enumerate}
\bigskip

\textbf{Exercise 2.}
\begin{itemize}
\item $T(n) = 2T(n-1) + 1$, $T(0)=1$.  Use the iteration method to find a $\Theta()$ evaluation for $T(n)$.
\item $T(n) = T(n-1) + 1$,  $T(0)=1$.  Use the iteration method to find a $\Theta()$ evaluation for $T(n)$.
\item Give a  $\Theta( \cdot)$ evaluation for the runtime of the following code:
\begin{verbatim}
 i= n
 while(i >=1) {
    for (j=1;  j <=n;  j++)
        x=x+1
    i = i/2
}    
\end{verbatim}
\item Give a  $\Theta( \cdot)$ evaluation for the runtime of the following code:
\begin{verbatim}
 i= n
 while(i >=1) {
    for (j=1;  j <=i;  j++)
        x=x+1
    i = i/2
}
\end{verbatim}
\end{itemize}
\newpage
\textbf{Programming Task 1.}

The input is an array $a_1, a_2, \ldots, a_n$ of numbers.  A  \emph{UP-pair} is a pair $(a_i, a_j)$  so that $1 \le i < j \le n$ and $a_i < a_j$. The task is to count the number of UP-pairs
in the array.

For example, for $n = 5$ and input sequence $7, 3, 8, 1, 5$, we have the following UP-pairs: $(7,8),  (3, 8),  (3, 5),  (1,5)$.  So, there are $4$ UP-pairs. 
Design an $O(n \log n)$ algorithm which computes the number of UP-pairs for a
given input sequence and implement your program in Java.

It's very easy to come up with an algorithm with run time  $\Theta(n^2)$ (just compare all pairs), but such an algorithm will not get any credit.

The idea of the $O(n \log n)$  algorithm is to modify MERGE-SORT (from page 34 in the textbook)  so that in addition to sorting the array it also counts the number of UP-pairs. Thus, your modified MERGE-SORT (A, p, r) will sort the segment of the array $A[p..r]$  (like in the textbook), but in addition to that will return the number of UP-pairs in this segment.  The main modification is in the MERGE  procedure, see textbook page 31. In the final for loop, you will also count the UP-pairs in which the first component is in $L$, and the second component is in $R$. Keep in mind that $L$ and $R$ are both sorted and therefore if $L[i] < R[j]$, then all pairs $(L[i], R[j]),  (L[i], R[j+1]), \ldots, (L[i], R[r])$ are UP-pairs. So with a single comparison you can add the number of these pairs to the counter of UP-pairs. Using this observation the modified MERGE can be implemented in $O(n)$ (the same runtime as the standard MERGE).
\medskip




Test your program and report in a table the results for the following data sets.

Data set 1:  7,3,8,1,5

Data set 2:  The  numbers from the file input-3.4, available on Blackboard. The first line of the line has the number of elements (which is 1000), and the next line has the elements.

Data set 3:  The  numbers from the file input-3.5, available on Blackboard. The first line of the line has the number of elements (which is 10000), and the next line has the elements.

 

 



















 
  
\bigskip


NOTE 2:  You can find an example of what I mean by  ``Describe an algorithm ..." at

\url{https://www.geeksforgeeks.org/find-the-element-that-appears-once-in-a-sorted-array/}

%\url{https://www.geeksforgeeks.org/cut-all-the-rods-with-some-length-such-that-the-sum-of-cut-off-length-is-maximized/}
%\medskip

%See the text that starts with \textbf{Approach}.
\newpage

\textbf{Programming Task 2.}


The input is a 2-dimensional  matrix cost[][] of integer numbers, with $n$ rows labeled $0,1, 2, \ldots, n-1$ and $m$ columns labeled $0,1,2,\ldots, m-1$, and also a target cell $(i,j)$. The task is to calculate the minimum cost path to reach cell (i, j) from cell (0, 0). Each cell of the matrix represents a cost to traverse through that cell. The total cost of a path to reach (i,j) is the sum of all the costs on that path (including both source and destination).
We can only traverse down, right,  and diagonally lower  from a given cell. Formally, from a given cell (i, j) one can move to one of the following cells: 

(i+1, j) (down)


(i, j+1) (right)



 and the diagonal moves are to (i+1, j+1), or to  (i+1,j-1).

\medskip

Example:  the input is the matrix cost below and the target cell $(2,1)$.
\medskip


\begin{tabular}{|c|c|c|}
\hline
1  & 2 & 3 \\
\hline
4 & 8 & 1 \\
\hline
1 & 5 & 3 \\
\hline

\end{tabular}
\medskip

Then the minimum cost to go from cell (0,0) to the target cell (2,1) is 9, corresponding to the path (0,0) -- (0,1) -- (1,2) -- (2,1).


Design a dynamic programming algorithm that solves this problem. The input should have the following format

line 1 consists of 4 numbers: n, m, i and j.

This is followed by n rows each one containing m numbers, giving the cost table.

For instance for the above problem the input is

3,3,2,1

1,2,3

4,8,1

1,5,3


Test your program and report in a table the results for the following data sets.

Data set 1:  The above example

Data set 2:  The  numbers from the file input-3.6, available on Blackboard. 

Data set 3:  The  numbers from the file input-3.7, available on Blackboard. 

\pagebreak
\begin{verbatim}
    
'Assignment3_T2' 
Integer Matrix Size : [3][3]
[ 1, 2, 3 ]
[ 4, 8, 1 ]
[ 1, 5, 3 ]

Optomize path (0, 0) to (2, 1)

Min cost path summations processed...
[ 1, 3, 6 ]
[ 5, 9, 4 ]
[ 6, 9, 7 ]

Min cost to cell  (2, 1) : 9


Input File Name : input-3.6.txt
Integer Matrix Size : [6][6]
[ 3, 1, 1, 1, 1, 1 ]
[ 1, 4, 2, 3, 5, 1 ]
[ 9, 1, 2, 3, 4, 5 ]
[ 1, 7, 2, 5, 4, 4 ]
[ 1, 1, 1, 1, 1, 1 ]
[ 1, 7, 1, 7, 1, 7 ]

Optomize path (0, 0) to (5, 5)

Min cost path summations processed...
[ 3, 4, 5, 6, 7, 8 ]
[ 4, 7, 6, 8, 11, 8 ]
[ 13, 5, 7, 9, 12, 13 ]
[ 6, 12, 7, 12, 13, 16 ]
[ 7, 7, 8, 8, 9, 10 ]
[ 8, 14, 8, 15, 9, 16 ]

Min cost to cell  (5, 5) : 16


Input File Name : input-3.7.txt
Integer Matrix Size : [8][5]
[ 1, 2, 3, 4, 5 ]
[ 5, 4, 3, 2, 1 ]
[ 1, 2, 3, 4, 5 ]
[ 5, 4, 3, 2, 1 ]
[ 1, 2, 3, 4, 5 ]
[ 5, 4, 3, 2, 1 ]
[ 1, 2, 3, 4, 5 ]
[ 5, 4, 3, 2, 1 ]

Optomize path (0, 0) to (7, 4)

Min cost path summations processed...
[ 1, 3, 6, 10, 15 ]
[ 6, 5, 6, 8, 9 ]
[ 6, 7, 8, 10, 13 ]
[ 11, 10, 10, 10, 11 ]
[ 11, 12, 13, 14, 15 ]
[ 16, 15, 15, 15, 15 ]
[ 16, 17, 18, 19, 20 ]
[ 21, 20, 20, 20, 20 ]

Min cost to cell  (7, 4) : 20

 */
\end{verbatim}


\pagebreak
\textbf{Task 2}
\begin{lstlisting}[language=Java]
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Assignment3_T2 {
    public static int rowF = 0;
    public static int colF = 0;

    public static void main(String[] args) throws FileNotFoundException {
        int[][] temp = new int[][]{ {1, 2, 3}, {4, 8, 1}, {1, 5, 3}};
        rowF = 2;
        colF = 1;
        print(temp, temp.length, temp[0].length);
        System.out.println("\nOptimize path (0, 0) to (" + rowF + ", " + colF + ")\n");
        System.out.println("\nMin cost to cell  (" + rowF + ", " + colF + ") : " + costOpti(temp)+"\n");
        
        
        int[][] x = fileInts();
        print(x, x.length, x[0].length);
        System.out.println("\nOptimize path (0, 0) to (" + rowF + ", " + colF + ")\n");
        System.out.println("\nMin cost to cell  (" + rowF + ", " + colF + ") : " + costOpti(x)+"\n");

        x = fileInts();
        print(x, x.length, x[0].length);
        System.out.println("\nOptimize path (0, 0) to (" + rowF + ", " + colF + ")\n");
        System.out.println("\nMin cost to cell  (" + rowF + ", " + colF + ") : " + costOpti(x)+"\n");

    }

    public static int costOpti(int[][] x) {

        int minInc[][] = new int[x.length][x[0].length];

        // Fill edge row with right only movements//
        minInc[0][0] = x[0][0];
        for (int i = 1; i < x[0].length; i++) {// Case only right moves: Top//
            int rightMoves = minInc[0][i - 1] + x[0][i];
            minInc[0][i] = rightMoves;
        }

        // Process array by layer as each element in a row > 0 has group of
        // Moves to choosen: cell0:(2), cell1:(4), cell2:(4), cell3:(4), ..., Last
        // index:(3)

        for (int k = 1; k < x.length; k++) {// all other rows//

            for (int j = 0; j < x[k].length; j++) {// in line//

                if (j == 0) {// First index of row//
                    int downMove = x[k][j] + minInc[k - 1][j];
                    int diag = x[k][j] + minInc[k - 1][j + 1];
                    minInc[k][j] = Math.min(downMove, diag);
                }

                else if (j < x[k].length - 1) {// Not at last index of row//
                    int downMove = x[k][j] + minInc[k - 1][j];
                    int diagUpRight = x[k][j] + minInc[k - 1][j + 1];
                    int diagUpLeft = x[k][j] + minInc[k - 1][j - 1];
                    int leftMoves = x[k][j] + minInc[k][j - 1];

                    minInc[k][j] = Math.min(Math.min(diagUpRight, diagUpLeft), Math.min(downMove, leftMoves));
                }

                else {// Last index of row//
                    int downMove = x[k][j] + minInc[k - 1][j];
                    int diagUpLeft = x[k][j] + minInc[k - 1][j - 1];
                    int leftMoves = x[k][j] + minInc[k][j - 1];

                    minInc[k][j] = Math.min(diagUpLeft, Math.min(downMove, leftMoves));

                }

            }
        }
        // Actually reviews all moves for each square
        // Does full array incase of negative cost areas...

        System.out.println("Min cost path summations processed...");
        print(minInc, minInc.length, minInc[0].length);

        return minInc[rowF][colF];
    }

    // Done : builds array from file correctly//
    public static int[][] fileInts() throws FileNotFoundException {
        Scanner scnr = new Scanner(System.in);

        System.out.print("Input File Name : ");
        String userVar = scnr.next();

        try {
            while (!new File(userVar).exists()) {
                System.out.print("Input File Name : ");
                userVar = scnr.next();
            }
            System.out.println();
            Scanner scnrX = new Scanner(new File(userVar));

            // Grab size row x col first//
            int n = scnrX.nextInt();
            int m = scnrX.nextInt();
            // Public static goal index//
            rowF = scnrX.nextInt();
            colF = scnrX.nextInt();

            int x[][] = new int[n][m];

            for (n = 0; n < x.length; n++) {
                for (m = 0; m < x[0].length; m++) {
                    if (scnrX.hasNextInt()) {
                        x[n][m] = scnrX.nextInt();
                    } else {// Out Of Room//
                        n = x.length;
                        m = x[0].length;
                    }
                }
            }

            return x;
        } catch (FileNotFoundException e) {
            System.out.println("Error File Not Found...");
            return null;
        }
    }

    // Print 2D int array//
    public static void print(int[][] y, int n, int m) {
        System.out.println("Integer Matrix Size : [" + n + "]" + "[" + m + "]");

        int i;
        int j;

        for (i = 0; i < n; i++) {
            System.out.print("[ ");

            for (j = 0; j < m; j++) {

                if (j != 0) {
                    System.out.print(", ");
                }
                System.out.print(y[i][j]);

            }

            System.out.println(" ]");

        }

    }
}
\end{lstlisting}

\end{document}
