\iffalse

INSTRUCTIONS: (if this is not lecture1.tex, use the right file name)

  Clip out the ********* INSERT HERE ********* bits below and insert
appropriate TeX code.  Once you are done with your file, run

  ``latex lecture1.tex''

from a UNIX prompt.  If your LaTeX code is clean, the latex will exit
back to a prompt.  Once this is done, run

  ``dvips lecture1.dvi''

which should print your file to the nearest printer.  There will be
residual files called lecture1.log, lecture1.aux, and lecture1.dvi.
All these can be deleted, but do not delete lecture1.tex.
\fi
%
\documentclass[11pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{pdfpages}
\usepackage{graphics}
\usepackage{graphicx}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
 
\urlstyle{same}

\setlength{\oddsidemargin}{.25in}
\setlength{\evensidemargin}{.25in}
\setlength{\textwidth}{6in}
\setlength{\topmargin}{-0.4in}
\setlength{\textheight}{8.5in}

\newcommand{\handout}[5]{
   %\renewcommand{\thepage}{#1-\arabic{page}}
   \noindent
   \begin{center}
   \framebox{
      \vbox{
    \hbox to 5.78in { {\bf Data Structures and Algorithms} \hfill #2 }
       \vspace{4mm}
       \hbox to 5.78in { {\Large \hfill #5  \hfill} }
       \vspace{2mm}
       \hbox to 5.78in { {\it #3 \hfill #4} }
      }
   }
   \end{center}
   \vspace*{4mm}
}

\newcommand{\lecture}[3]{\handout{L#1}{#2}{}{}{#1}}

\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}
\def\qed{\hspace*{\fill}
        \vbox{\hrule\hbox{\vrule\squarebox{.667em}\vrule}\hrule}}
\newenvironment{solution}{\begin{trivlist}\item[]{\bf Solution:}}
                      {\qed \end{trivlist}}
\newenvironment{solsketch}{\begin{trivlist}\item[]{\bf Solution Sketch:}}
                      {\qed \end{trivlist}}
\newenvironment{proof}{\begin{trivlist}\item[]{\bf Proof:}}
                      {\qed \end{trivlist}}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{Assertion}[theorem]{Assertion}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{hypothesis}[theorem]{Hypothesis}
%\newtheorem{observation}[theorem]{Observation}
%\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{assumption}[theorem]{Assumption}

%Put more macros here, as needed.
\newcommand{\al}{\alpha}
\newcommand{\Z}{\mathbb Z}
\newcommand{\jac}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\set}[1]{\{#1\}}

\def\ppt{{\sf PPT}}
\def\poly{{\sf poly}}
\def\negl{{\sf negl}}
\def\owf{{\sf OWF}}
\def\owp{{\sf OWP}}
\def\tdp{{\sf TDP}}
\def\prg{{\sf PRG}}
\def\prf{{\sf PRF}}

%end of macros
\begin{document}

\fbox{
\vbox{
\begin{flushleft}
Ann,  Bob, Charlie    (\emph{replace with your names and correct the date})\\  % authors' names
COSC 336 \\  %class
3/19/2500\\  % date
\end{flushleft}
\center{\Large{\textbf{Assignment 6}}}
} % end vbox
} % end fbox
\vline

\textbf{Instructions.}
\begin{enumerate}
\item Due date and time: As indicated on Blackboard. 
\item This is a team assignment. Work in teams of 3-4 students.  Submit on Blackboard one assignment per team, with the names of all students making the team. 
\item The exercises will not be graded, but you still need to present your best attempt to solve them. If you do not know how to solve an exercise, say it.  This will give me feedback about your understanding of the theoretical concepts.
\item Your programs must be written in Java.

\item Write your programs neatly - imagine yourself grading your program and see if it is easy to read and understand. 

Comment your programs reasonably: there is no need to comment lines like "i++" but do include brief comments describing the main purpose of a specific block of lines.
\item  You will submit on \textbf{Blackboard} 2 files.  

The \textbf{1-st file} is a pdf file (produced ideally with latex and Overleaf) and it will contain the following:
\begin{enumerate}
\item The solution to the Exercises (see the remark above).
\item   A short description of your algorithm for the Programming Task.
\item   A table with the results your program gives  for the data sets indicated for the programming task. 
\item   The java code (so that the grader can make observations) of the  program.
\end{enumerate}


The \textbf{2-nd file} is the .java file containing the java source code for Programming Task.

\end{enumerate}
\newpage










\textbf{Exercise 1.} Consider inserting the keys $10, 22, 31, 4, 15, 28, 17, 88, 59$ into a hash table of length $m=11$ using open addressing with the  hash function $h(x) = x \pmod{11}$ and linear probing, quadratic probing, and double probing. Illustrate  the result by showing the 3 tables obtained  after inserting these keys using 

$\bullet$ linear probing, 

$\bullet$ quadratic probing



$\bullet$ double hashing with $h_1(x) = x \pmod{11} $ and $h_2(x) = 7 - x \pmod{7}$.
  
\textbf{Answer:}
\bigskip




\textbf{Exercise 2.}  Recall the \textsf{Partition} subroutine employed by \textsf{QuickSort}. You are told that the following array has been partitioned around some pivot element:
\medskip

\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline 
3 & 1& 2 & 4 &5 &8 & 7 & 6 & 9 \\
\hline
\end{tabular}
\medskip

Which of the elements could have been the pivot element? (List all that apply; there could be more than one possibility.)
\medskip

%\textbf{Answer:}
\bigskip


\textbf{Exercise 3.}
Let $\alpha$ be some constant, independent of the input array length $n$, strictly between $0$ and $1/2$. What is the probability that, with a randomly chosen pivot element, the \textsf{Partition} function produces a split in which the size of both the resulting subproblems is at least $\alpha \cdot n$. Choose the answer from the following list and justify your answer.
\begin{itemize}
\item $\alpha$
\item $1 - \alpha$
\item $1-2\alpha$
\item $2 - 2 \alpha$
\end{itemize}
\medskip

%\textbf{Answer:}
\bigskip


\newpage



\textbf{Programming task} The program involves various operations for binary search trees. Your task is to modify the program  at

%\url{https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/}

\url{https://www.geeksforgeeks.org/insertion-in-binary-search-tree/?ref=lbp}
\medskip

$\bullet$ Add to the class \textsf{Node}  a data member called \textsf{int size} which keeps the number of nodes in the tree rooted at that node (including in the count the node itself). The constructors and the insertion function need to take into account the sizes of the nodes.
\medskip

$\bullet$ Modify the \textsf{insert} function so that duplicates are also inserted (which is not done in the version at the above link). If the value $x$  to be inserted is equal to the value in the root, insert $x$ in the left subtree.
\medskip





$\bullet$  Write two functions called \textsf{leftRotate (Node t)}, which rotates the root t to the left, so that the right child of t (if there is one; otherwise the rotation does not do anything) becomes the parent of t, and symmetrically  \textsf{rightRotate (Node t) which rotates the root to the right}. See Figure 13.2, page 313 in the textbook, or Notes 6 on Blackboard. Note that when you do \textsf{leftRotate (Node t)}, you need to change the size of \textsf{t} and of \textsf{t.right}, and similarly for \textsf{rightRotate}.


\tikzset{every tree node/.style={minimum width=2em,draw,circle},
         blank/.style={draw=none},
         edge from parent/.style=
         {draw,edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
         level distance=1.5cm}
\begin{tikzpicture}
\Tree
[.7     
    [.3 ]
    [.10
    \edge[]; {9}
    \edge[]; [.13
             \edge[]; {11}
             \edge[blank]; \node[blank]{};
         ]
    ]
]
\end{tikzpicture}

For instance for the tree in the figure,  node 7 has size 6, node 3 has size 1, node 9 has size 1, node 10 has size 4, node 13 has size 2, and node 11 has size 1.

If we do \textsf{leftRotate} for the root we get the tree

\begin{tikzpicture}
\Tree
[.10   
    [.7 
    \edge[]; {3}
    \edge[]; {9}
    ]
[.13 \edge[]; {11}
\edge[blank]; \node[blank]{};]
]
\end{tikzpicture}

To test the augmented class, you will insert some values and then do a \emph{preorder} traversals and print in this order  the pairs (value, size) of all the nodes. 	Next, you \textsf{leftRotate} the root and print again the tree after rotation. In other words, you do a preorder traversal \textbf{before and after} the rotation, but print the elements in this order.

\textbf{Test data 1:} insert 7, 10, 3, 9, 13, 11. Your program will print: (7,6), (3,1), (10,4), (9,1), (13, 2), (11,1).
Next, do a \textsf{leftRotate}, and print the tree after rotation and you get (10,6), (7,3), (3,1), (9,1) (13,2), (11, 1).




\textbf{Test data 2:}  Insert one by one the numbers in the file input-6.1. The first line contains how many numbers are there (there are 1000 numbers), and the next line contains the list of numbers.

Report in the pdf file the first 25 pairs (you do complete preorder traversals before and after but report only the first 25 elements).

\textbf{Test data 3:} Insert one by one the numbers in the file input-6.2. The first line contains how many numbers are there (there are 10000 numbers), and the next line contains the list of numbers.

Report in the pdf file the first 25 pairs (as above).


\end{document}
